##' ---
##' title: "Appendix: `total_trade_CPC` module"
##' author:
##'   - Marco Garieri
##'   - Alexander Matrunich
##'   - Christian A. Mongeau Ospina
##'   - Bo Werth\
##'
##'     Food and Agriculture Organization of the United Nations
##' date: "`r format(Sys.time(), '%e %B %Y')`"
##' output:
##'    pdf_document
##' ---

##' This module aggregates total trade flow by reporting country for partners
##' countries to a single total trade for each unique CPC commodity code. The
##' module saves the ouput into the dataset `total\_trade\_cpc\_m49`,
##' within the `trade` domain.

##+ setup, include=FALSE
knitr::opts_chunk$set(echo = FALSE, eval = FALSE)

# Year for processing
library(data.table)
library(faoswsTrade)
library(faosws)
library(stringr)
library(scales)
library(faoswsUtil)
library(faoswsFlag)
library(tidyr)
library(dplyr, warn.conflicts = FALSE)

##+ init

# If this is set to TRUE, the module will download the whole dataset
# saved on SWS (year specific) and will do a setdiff by comparing this
# set and the dataset generated by the module: all values saved on SWS
# that are not generated by the current run should be considered "wrong"
# (e.g., generated by a previous run of the module that had a bug) and
# will then be set to NA. See issue #164
remove_nonexistent_transactions <- TRUE

local({
  min_versions <- data.frame(package = c("faoswsFlag", "faoswsTrade"),
                             version = c('0.2.4', '0.1.1'),
                             stringsAsFactors = FALSE)

  for (i in nrow(min_versions)){
    # installed version
    p <- packageVersion(min_versions[i,"package"])
    # required version
    v <- package_version(min_versions[i,"version"])
    if(p < v){

      stop(sprintf("%s >= %s required", min_versions[i,"package"], v))
    }
  }

})


if(CheckDebug()){
  library(faoswsModules)
  SETTINGS = ReadSettings("modules/total_trade_CPC/sws.yml")
  ## Define where your certificates are stored
  faosws::SetClientFiles(SETTINGS[["certdir"]])
  ## Get session information from SWS. Token must be obtained from web interface
  GetTestEnvironment(baseUrl = SETTINGS[["server"]],
                     token = SETTINGS[["token"]])
}

##' # Parameters

##' - `year`: year for processing.
year <- as.integer(swsContext.computationParams$year)

startTime = Sys.time()

if (!CheckDebug()) {
  updateInfoTable(
    year  = year,
    table = 'total_tf_runs_info',
    mode  = 'restart'
  )
}

##' # Import Data from Complete TF CPC
##'
##' Import monetary values and quantities from data previously generated by
##' the `complete_tf_cpc` module.
##'
##' 1. `5608`: Import Quantity (heads)
##' 1. `5609`: Import Quantity (1000 heads)
##' 1. `5610`: Import Quantity (tonne)
##' 1. `5908`: Export Quantity (heads)
##' 1. `5909`: Export Quantity (1000 heads)
##' 1. `5910`: Export Quantity (tonne)
##' 1. `5622`: Imports (US$)
##' 1. `5922`: Exports (US$)

##+ import

allReportersDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "geographicAreaM49Reporter")[type == "country", code] %>%
  Dimension(name = "geographicAreaM49Reporter", keys = .)

allPartnersDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "geographicAreaM49Partner")[type == "country", code] %>%
  Dimension(name = "geographicAreaM49Partner", keys = .)

allElementsDim <-
  c("5608", "5609", "5610", "5908", "5909", "5910", "5622", "5922") %>%
  Dimension(name = "measuredElementTrade", keys = .)

allItemsDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "measuredItemCPC")[,code] %>%
  Dimension(name = "measuredItemCPC", keys = .)

allYearsDim <- Dimension(name = "timePointYears", keys = as.character(year))

completetradekey <-
  DatasetKey(
    domain = "trade",
    dataset = "completed_tf_cpc_m49",
      dimensions =
        list(
          allReportersDim,
          allPartnersDim,
          allElementsDim,
          allItemsDim,
          allYearsDim
        )
  )

completetrade <- tbl_df(GetData(completetradekey))

##' # Aggregate values across partner dimension
##'
##' - ignore missing values in aggregation
##' - aggregate flags using the `flagWeightTable`

##+ flagWeightTable, results='asis'
knitr::kable(faoswsFlag::flagWeightTable)

##+ aggregate

completetrade <- completetrade %>%
  mutate_(geographicAreaM49 = ~geographicAreaM49Reporter)

flagWeightTable_status <- frame_data(
  ~flagObservationStatus, ~flagObservationWeights,
  'X',                   1.00,
  '',                    0.99,
  'T',                   0.80,
  'E',                   0.75,
  'I',                   0.50,
  'M',                   0.00
)

# This shouldn't ever be needed as all values are a sum ("s")
flagWeightTable_method <- frame_data(
  ~flagObservationStatus, ~flagObservationWeights,
  'h',                   1.00,
  'i',                   0.80,
  'e',                   0.60,
  'c',                   0.40,
  's',                   0.20
)

total_trade_cpc_wo_uv <-
  completetrade %>%
  select_(
    ~geographicAreaM49, ~geographicAreaM49Partner, ~timePointYears,
    ~measuredItemCPC, ~measuredElementTrade, ~Value, ~flagObservationStatus
  ) %>%
  group_by_(
    ~geographicAreaM49,
    ~timePointYears,
    ~measuredItemCPC,
    ~measuredElementTrade
  ) %>%
  summarise_(
    Value = ~sum(Value, na.rm = TRUE),
    flagObservationStatus =
      ~aggregateObservationFlag(
        flagObservationStatus, flagTable = flagWeightTable_status
      )
  ) %>%
  ungroup() %>%
  dplyr::mutate(flagMethod = "s")

##' # Calculate Unit Values
##'
##' Calculate unit value (US$ per quantity unit) at CPC level if the quantity is
##' larger than zero
##'
##' 1. `5630`: Import Unit Value (US$ / tonne)
##' 1. `5638`: Import Unit Value (US$ / heads)
##' 1. `5639`: Import Unit Value (US$ / 1000 heads)
##' 1. `5930`: Export Unit Value (US$ / tonne)
##' 1. `5938`: Export Unit Value (US$ / heads)
##' 1. `5939`: Export Unit Value (US$ / 1000 heads)
##'
##' - use `flagObservationsStatus` from quantity measures
##' - set `flagMethod` to `i` for unit values calculated as identity

##+ unit-value

addUV <- function(data) {

  ## data <- total_trade_cpc
  copyData <- data

  copyData$unit <- ifelse(copyData$measuredElementTrade %in% c("5622", "5922"), "monetary", "quantity")
  copyData$flow <- ifelse(substr(copyData$measuredElementTrade, 1, 2) == "56", "import", "export")

  copyData_quantity <-
    copyData %>%
    dplyr::filter(unit == "quantity") %>%
    select(
      -unit,
      measuredElementTrade.qty = measuredElementTrade,
      -flagMethod
    )
    ## select(-unit) # must keep to assign proper elemnt code to unit value

  copyData_monetary <-
    copyData %>%
    dplyr::filter(unit == "monetary") %>%
    select(
      -unit,
      -measuredElementTrade,
      -flagObservationStatus,
      -flagMethod
    )

  me_qty_uv <-
    data.frame(
      flow = c(rep("import", 3), rep("export", 3)),
      measuredElementTrade.qty = c("5608", "5609", "5610", "5908", "5909", "5910"),
      measuredElementTrade = c("5638", "5639", "5630", "5938", "5939", "5930"),
      stringsAsFactors = FALSE
    )

  copyData_uv <-
    copyData_quantity %>%
    left_join(
      copyData_monetary,
      by = c("geographicAreaM49", "timePointYears", "measuredItemCPC","flow"),
      suffix = c(".qty", ".mon")
    ) %>%
    dplyr::mutate(
      Value = ifelse(Value.qty > 0, Value.mon * 1000 / Value.qty, NA)
    ) %>%
    left_join(me_qty_uv) %>%
    ## ## only keep columns already present in input data set
    dplyr::mutate(flagMethod = "i") %>%
    subset(., select = names(data))

  return(copyData_uv)

}

total_trade_cpc_uv <-
  addUV(total_trade_cpc_wo_uv) %>%
  dplyr::filter(!is.na(Value))


total_trade_cpc_w_uv <-
  total_trade_cpc_wo_uv %>%
  bind_rows(total_trade_cpc_uv) %>%
  data.table::as.data.table()

table(total_trade_cpc_w_uv$flagObservationStatus, total_trade_cpc_w_uv$flagMethod)

## total_trade_cpc_w_uv$flagMethod = "s"

if (remove_nonexistent_transactions) {
  #flog.trace("[%s] Remove non-existent transactions (RNET)", PID, name = "dev")

  GetCodeList2 <- function(dimension = NA) {
    GetCodeList(
      domain    = 'trade',
      dataset   = 'total_trade_cpc_m49',
      dimension = dimension
    )
  }

  Keys <-
    list(
      reporters = GetCodeList2(dimension = 'geographicAreaM49')[type == 'country', code],
      items     = GetCodeList2(dimension = 'measuredItemCPC')[, code],
      elements  = GetCodeList2(dimension = 'measuredElementTrade')[, code],
      years     = as.character(year)
    )

  # TODO: use error handling
  key <-
    DatasetKey(
      domain     = 'trade',
      dataset    = 'total_trade_cpc_m49',
      dimensions =
        list(
          Dimension(name = 'geographicAreaM49',    keys = Keys[['reporters']]),
          Dimension(name = 'measuredItemCPC',      keys = Keys[['items']]),
          Dimension(name = 'measuredElementTrade', keys = Keys[['elements']]),
          Dimension(name = 'timePointYears',       keys = Keys[['years']])
        )
    )

  #flog.trace("[%s] RNET: Download existent SWS dataset", PID, name = "dev")

  existing_data <- GetData(key = key, omitna = TRUE)

  # Difference between what was saved and what the module produced:
  # whatever is not produced in the run should be set to NA. See #164
  # (No need of year as key as all data refer to the same year)
  data_diff <- existing_data[!total_trade_cpc_w_uv,
                             on = c('geographicAreaM49',
                                    'measuredElementTrade',
                                    'measuredItemCPC')]

  if (nrow(data_diff) > 0) {
    #flog.trace("[%s] RNET: Non-existent transactions set to NA", PID, name = "dev")

    data_diff[,`:=`(Value                 = NA_real_,
                    flagObservationStatus = NA_character_,
                    flagMethod            = NA_character_)]

    total_trade_cpc_w_uv <- rbind(total_trade_cpc_w_uv, data_diff)
  } #else {
    #flog.trace("[%s] RNET: There are no non-existent transactions", PID, name = "dev")
  #}
}

##' # Save the `total_trade_cpc_m49` dataset to the `trade` domain

stats <- SaveData("trade",
                  "total_trade_cpc_m49",
                  total_trade_cpc_w_uv)

if (!CheckDebug()) {
  updateInfoTable(
    year    = year,
    table   = 'total_tf_runs_info',
    mode    = 'save',
    results = stats
  )
}

sprintf(
  "Module completed in %1.2f minutes.
  Values inserted: %s
  appended: %s
  ignored: %s
  discarded: %s",
  difftime(Sys.time(), startTime, units = "min"),
  stats[["inserted"]],
  stats[["appended"]],
  stats[["ignored"]],
  stats[["discarded"]]
)

### TO DO FCL
#total_trade_fcl <- total_trade %>%
#  transmute_(geographicAreaM49 = ~reporterM49,
#             measuredElementTrade = ~ifelse(flow == 1,
#                                            "5610",
#                                            ifelse(flow == 2,
#                                                   "5910",
#                                                   NA)),
#             measuredItemFS = ~fcl,
#             timePointYears = ~year,
#             flagObservationStatus = ~flagObservationStatus,
#             flagMethod = ~flagMethod,
#             qty = ~qty,
#             fclunit = ~fclunit,
#             value = ~value)


