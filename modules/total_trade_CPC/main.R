##' ---
##' title: "Appendix: `total_trade_CPC` module"
##' author:
##'   - Marco Garieri
##'   - Alexander Matrunich
##'   - Christian A. Mongeau Ospina
##'   - Bo Werth\
##'
##'     Food and Agriculture Organization of the United Nations
##' date: "`r format(Sys.time(), '%e %B %Y')`"
##' output:
##'    pdf_document
##' ---

##' This module aggregates total trade flow by reporting country for partners
##' countries to a single total trade for each unique CPC commodity code. The
##' module saves the ouput into the dataset `total\_trade\_cpc\_m49`,
##' within the `trade` domain.

##+ setup, include=FALSE
knitr::opts_chunk$set(echo = FALSE, eval = FALSE)

library(data.table)
library(faoswsTrade)
library(faosws)
library(stringr)
library(scales)
library(faoswsUtil)
library(faoswsFlag)
library(tidyr)
library(dplyr, warn.conflicts = FALSE)

##+ init

# If this is set to TRUE, the module will download the whole dataset
# saved on SWS (year specific) and will do a setdiff by comparing this
# set and the dataset generated by the module: all values saved on SWS
# that are not generated by the current run should be considered "wrong"
# (e.g., generated by a previous run of the module that had a bug) and
# will then be set to NA. See issue #164
remove_nonexistent_transactions <- TRUE

local({
  min_versions <- data.frame(package = c("faoswsFlag", "faoswsTrade"),
                             version = c('0.2.4', '0.1.1'),
                             stringsAsFactors = FALSE)

  for (i in nrow(min_versions)){
    # installed version
    p <- packageVersion(min_versions[i,"package"])
    # required version
    v <- package_version(min_versions[i,"version"])
    if(p < v){

      stop(sprintf("%s >= %s required", min_versions[i,"package"], v))
    }
  }

})


if (CheckDebug()) {
  library(faoswsModules)
  SETTINGS = ReadSettings("modules/total_trade_CPC/sws.yml")
  ## Define where your certificates are stored
  faosws::SetClientFiles(SETTINGS[["certdir"]])
  ## Get session information from SWS. Token must be obtained from web interface
  GetTestEnvironment(baseUrl = SETTINGS[["server"]],
                     token = SETTINGS[["token"]])
}

##' # Parameters

##' - `year`: year for processing.
year <- as.integer(swsContext.computationParams$year)

startTime = Sys.time()

if (!CheckDebug()) {
  updateInfoTable(
    year  = year,
    table = 'total_tf_runs_info',
    mode  = 'restart'
  )
}

##+ import

##' # Import Data from Complete TF CPC
##'
##' Import monetary values and quantities from data previously
##' generated by the `complete_tf_cpc` module.
##'
##' 1. `5608`: Import Quantity (heads)
##' 1. `5609`: Import Quantity (1000 heads)
##' 1. `5610`: Import Quantity (tonnes)
##' 1. `5908`: Export Quantity (heads)
##' 1. `5909`: Export Quantity (1000 heads)
##' 1. `5910`: Export Quantity (tonnes)
##' 1. `5622`: Imports (1,000 US$)
##' 1. `5922`: Exports (1,000 US$)
##'
##' The query is done for all reporters, all partners, all elements
##' (indicated above), all items, and the year indicated in `year`.

allReportersDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "geographicAreaM49Reporter")[type == "country", code] %>%
  Dimension(name = "geographicAreaM49Reporter", keys = .)

allPartnersDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "geographicAreaM49Partner")[type == "country", code] %>%
  Dimension(name = "geographicAreaM49Partner", keys = .)

allElementsDim <-
  c("5608", "5609", "5610", "5908", "5909", "5910", "5622", "5922") %>%
  Dimension(name = "measuredElementTrade", keys = .)

allItemsDim <-
  GetCodeList("trade", "completed_tf_cpc_m49", "measuredItemCPC")[,code] %>%
  Dimension(name = "measuredItemCPC", keys = .)

allYearsDim <- Dimension(name = "timePointYears", keys = as.character(year))

completetradekey <-
  DatasetKey(
    domain = "trade",
    dataset = "completed_tf_cpc_m49",
      dimensions =
        list(
          allReportersDim,
          allPartnersDim,
          allElementsDim,
          allItemsDim,
          allYearsDim
        )
  )

completetrade <-
  GetData(completetradekey) %>%
  tbl_df() %>%
  rename_(geographicAreaM49 = ~geographicAreaM49Reporter)

##' # Aggregate values across partner dimension
##'
##' Bilateral trade data (from the `complete_tf_cpc` module) for each
##' reporter/flow/year/item combination is aggregated for all partners.
##'
##' Note that:
##'
##' - missing values are ignored in the aggregation (i.e., set to zero)
##' - the aggregation of flags is done using the `flagWeightTable` from
##'   the `faoswsFlag` package.

##+ flagWeightTable, results='asis'
knitr::kable(faoswsFlag::flagWeightTable)

##+ aggregate

flagWeightTable_status <- frame_data(
  ~flagObservationStatus, ~flagObservationWeights,
  'X',                   1.00,
  '',                    0.99,
  'T',                   0.80,
  'E',                   0.75,
  'I',                   0.50,
  'M',                   0.00
)

# This shouldn't ever be needed as all values are a sum ("s")
# XXX No, not really: there are some reporters that for some
# commodities and flow have just one partner
flagWeightTable_method <- frame_data(
  ~flagObservationStatus, ~flagObservationWeights,
  'h',                   1.00,
  # XXX check why some are blanks
  '',                    0.99,
  'i',                   0.80,
  'e',                   0.60,
  'c',                   0.40,
  's',                   0.20
)

total_trade_cpc_wo_uv <-
  completetrade %>%
  group_by_(
    ~geographicAreaM49,
    ~timePointYears,
    ~measuredItemCPC,
    ~measuredElementTrade
  ) %>%
  summarise_(
    Value = ~sum(Value, na.rm = TRUE),
    flagObservationStatus =
      ~aggregateObservationFlag(
        flagObservationStatus,
        flagTable = flagWeightTable_status
      ),
    flagMethod =
      ~aggregateObservationFlag(
        flagMethod,
        flagTable = flagWeightTable_method
      ),
    nobs = ~n()
  ) %>%
  ungroup() %>%
  # In any case, 's' is the weakest flag, so that if aggregation
  # was performed, then 's' is the final Method flag.
  dplyr::mutate(flagMethod = ifelse(nobs > 1, 's', flagMethod)) %>%
  select(-nobs)

# Data for which weight and numbers were computed
# (n == 4 => (value, qty) * (import, export)
qty_and_weight <-
    completetrade %>%
    group_by(measuredItemCPC) %>%
    dplyr::summarise(n = n_distinct(measuredElementTrade)) %>%
    dplyr::filter(n > 4) %>%
    dplyr::mutate(out = TRUE) %>%
    select(-n)

qty_and_weight <-
  bind_rows(
    dplyr::mutate(qty_and_weight, measuredElementTrade = '5610'),
    dplyr::mutate(qty_and_weight, measuredElementTrade = '5910')
  )

# Keep only weights of livestock
total_trade_cpc_weight_livestock <-
  left_join(
    total_trade_cpc_wo_uv,
    qty_and_weight,
    by = c("measuredItemCPC", "measuredElementTrade")
  ) %>%
  dplyr::filter(out) %>%
  select(-out)

# Remove weights of livestok (keeping heads)
total_trade_cpc_wo_uv <-
  left_join(
    total_trade_cpc_wo_uv,
    qty_and_weight,
    by = c("measuredItemCPC", "measuredElementTrade")
  ) %>%
  dplyr::filter(is.na(out)) %>%
  select(-out)


##' # Calculate Unit Values
##'
##' Calculate unit value (US$ per quantity unit) at CPC level if the
##' quantity is greater than zero (if the quantity happens to be equal
##' to zero, the unit value is set to NA).
##'
##' - use `flagObservationsStatus` from quantity measures
##' - set `flagMethod` to `i` for unit values (calculated as identity)
##'
##' The created elements are:
##'
##' - `5630`: Import Unit Value (US$ / tonne)
##' - `5638`: Import Unit Value (US$ / heads)
##' - `5639`: Import Unit Value (US$ / 1000 heads)
##' - `5930`: Export Unit Value (US$ / tonne)
##' - `5938`: Export Unit Value (US$ / heads)
##' - `5939`: Export Unit Value (US$ / 1000 heads)

##+ unit-value

addUV <- function(data) {

  ## data <- total_trade_cpc
  copyData <- data

  copyData$unit <- ifelse(copyData$measuredElementTrade %in% c("5622", "5922"), "monetary", "quantity")
  copyData$flow <- ifelse(substr(copyData$measuredElementTrade, 1, 2) == "56", "import", "export")

  copyData_quantity <-
    copyData %>%
    dplyr::filter(unit == "quantity") %>%
    select(
      -unit,
      measuredElementTrade.qty = measuredElementTrade,
      -flagMethod
    )
    ## select(-unit) # must keep to assign proper elemnt code to unit value

  copyData_monetary <-
    copyData %>%
    dplyr::filter(unit == "monetary") %>%
    select(
      -unit,
      -measuredElementTrade,
      -flagObservationStatus,
      -flagMethod
    )

  me_qty_uv <-
    data.frame(
      flow = c(rep("import", 3), rep("export", 3)),
      measuredElementTrade.qty = c("5608", "5609", "5610", "5908", "5909", "5910"),
      measuredElementTrade = c("5638", "5639", "5630", "5938", "5939", "5930"),
      stringsAsFactors = FALSE
    )

  copyData_uv <-
    copyData_quantity %>%
    left_join(
      copyData_monetary,
      by = c("geographicAreaM49", "timePointYears", "measuredItemCPC","flow"),
      suffix = c(".qty", ".mon")
    ) %>%
    dplyr::mutate(
      Value = ifelse(Value.qty > 0, Value.mon * 1000 / Value.qty, NA)
    ) %>%
    left_join(me_qty_uv) %>%
    ## ## only keep columns already present in input data set
    dplyr::mutate(flagMethod = "i") %>%
    subset(., select = names(data))

  return(copyData_uv)

}

total_trade_cpc_uv <-
  addUV(total_trade_cpc_wo_uv) %>%
  dplyr::filter(!is.na(Value))


total_trade_cpc_w_uv <-
  bind_rows(
    total_trade_cpc_uv,
    total_trade_cpc_wo_uv,
    total_trade_cpc_weight_livestock
  ) %>%
  data.table::as.data.table()

table(total_trade_cpc_w_uv$flagObservationStatus, total_trade_cpc_w_uv$flagMethod)

##' # Remove "non-existent" transactions
##'
##' It can happen that a given observation was generated by a previous
##' run of the module, but in a subsequent run it is not generated. This
##' happens mainly because bug-fixes were introduced so that an observation
##' that should not have existed is, correctly, not generated by a fixed
##' version of the module. If no overwrite of the observation that should
##' not exist happens, then it lives in the dataset "forever". Thus, the
##' latest version of the data is downloaded, it is checked which observations
##' are not generated by the current run of the module (considered the most
##' correct version), and all observations that were previously saved in the
##' dataset but are not in the current output are set to NA. This increases
##' the computation time of the module (it needs to download the complete
##' trade dataset), but guarantees that data that should not exist is not
##' saved in the dataset.

if (remove_nonexistent_transactions) {
  #flog.trace("[%s] Remove non-existent transactions (RNET)", PID, name = "dev")


  allReportersDim_tot <-
    GetCodeList("trade", "total_trade_cpc_m49", "geographicAreaM49")[type == "country", code] %>%
    Dimension(name = "geographicAreaM49", keys = .)

  allElementsDim_tot <-
    c("5608", "5609", "5610", "5908", "5909", "5910", "5622", "5922") %>%
    Dimension(name = "measuredElementTrade", keys = .)

  allItemsDim_tot <-
    GetCodeList("trade", "total_trade_cpc_m49", "measuredItemCPC")[,code] %>%
    Dimension(name = "measuredItemCPC", keys = .)

  totaltradekey <-
    DatasetKey(
      domain = "trade",
      dataset = "total_trade_cpc_m49",
        dimensions =
          list(
            allReportersDim_tot,
            allElementsDim_tot,
            allItemsDim_tot,
            allYearsDim
          )
    )

  #flog.trace("[%s] RNET: Download existent SWS dataset", PID, name = "dev")

  existing_data <- GetData(key = totaltradekey, omitna = TRUE)

  flog.trace("[%s] Keep protected data", PID, name = "dev")

  # Some flags are "protected", i.e., data with these flags
  # should not be overwritten/removed
  protected_flags <-
    flagValidTable[Protected == TRUE &
                   !(flagObservationStatus == 'T' &  flagMethod == 'c') &
                   !(flagObservationStatus == ''  &  flagMethod == 'c') &
                   !(flagObservationStatus == ''  &  flagMethod == 'h'),
                   paste(flagObservationStatus, flagMethod)]

  # Data that should be left untouched
  protected_data <-
    existing_data[paste(flagObservationStatus, flagMethod) %in% protected_flags,]

  # XXX If timePointYears will eventually be used they need to
  # have the same class in existing_data and total_trade_cpc_w_uv

  # Remove from saved data
  existing_data <-
    existing_data[!protected_data,
                  on = c('geographicAreaM49Reporter',
                         'geographicAreaM49Partner',
                         'measuredElementTrade',
                         'measuredItemCPC')]

  # Remove from new data
  total_trade_cpc_w_uv <-
    total_trade_cpc_w_uv[!protected_data,
                            on = c('geographicAreaM49Reporter',
                                   'geographicAreaM49Partner',
                                   'measuredElementTrade',
                                   'measuredItemCPC')]


  # Difference between what was saved and what the module produced:
  # whatever is not produced in the run should be set to NA. See #164
  # (No need of year as key as all data refer to the same year)
  data_diff <-
    existing_data[!total_trade_cpc_w_uv,
                  on = c('geographicAreaM49',
                         'measuredElementTrade',
                         'measuredItemCPC')]

  if (nrow(data_diff) > 0) {
    #flog.trace("[%s] RNET: Non-existent transactions set to NA", PID, name = "dev")

    data_diff[,`:=`(Value                 = NA_real_,
                    flagObservationStatus = NA_character_,
                    flagMethod            = NA_character_)]

    total_trade_cpc_w_uv <- rbind(total_trade_cpc_w_uv, data_diff)
  } #else {
    #flog.trace("[%s] RNET: There are no non-existent transactions", PID, name = "dev")
  #}
}

##' # Save data
##'
##' Saved data will be available in the "Total Trade (CPC)" dataset
##' (`total_trade_cpc_m49`) of the `trade` domain.

stats <- SaveData("trade",
                  "total_trade_cpc_m49",
                  total_trade_cpc_w_uv)

if (!CheckDebug()) {
  updateInfoTable(
    year    = year,
    table   = 'total_tf_runs_info',
    mode    = 'save',
    results = stats
  )
}

sprintf(
  "Module completed in %1.2f minutes.
  Values inserted: %s
  appended: %s
  ignored: %s
  discarded: %s",
  difftime(Sys.time(), startTime, units = "min"),
  stats[["inserted"]],
  stats[["appended"]],
  stats[["ignored"]],
  stats[["discarded"]]
)

### TO DO FCL
#total_trade_fcl <- total_trade %>%
#  transmute_(geographicAreaM49 = ~reporterM49,
#             measuredElementTrade = ~ifelse(flow == 1,
#                                            "5610",
#                                            ifelse(flow == 2,
#                                                   "5910",
#                                                   NA)),
#             measuredItemFS = ~fcl,
#             timePointYears = ~year,
#             flagObservationStatus = ~flagObservationStatus,
#             flagMethod = ~flagMethod,
#             qty = ~qty,
#             fclunit = ~fclunit,
#             value = ~value)


